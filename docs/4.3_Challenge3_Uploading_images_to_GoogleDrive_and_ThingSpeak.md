# Challenge 3: Uploading Images to Google Drive and ThingSpeak

<img src="./images/Images_upload_googledrive_thingspeak.png">

## Background

In this challenge, we will integrate a camera into our main application. To make this complex task more manageable and easier to debug, we will approach it in three parts.

### Part 1: Manual Image Capture and Saving to SD Card

**The source code for this part is available in the `Code/9_Images_SnapShot_to_SDCard/` folder.**

First, format an SD Card to FAT32.

<img src="./images/SDCard.jpg">

<img src="./images/SDCard_format.png">

Next, insert the SD card into the SD Card socket on your board.

<img src="./images/SDCard_in_socket.jpg">

After loading the program onto the ESP32-S3, open the Serial Monitor. You will see the following messages from the `setup()` function:

<img src="./images/Setup_message.png">

You can capture an image and save it to the SD Card in one of two ways:

1.  Press the **BOOT (IO0)** button on the ESP32-S3 board.
2.  Send a valid command through the Serial Monitor in the format `size quality`. For example, typing `10 10` and pressing Enter will set the image size to `10` (FRAMESIZE_XGA) and the JPEG quality to `10`. The valid range for `size` is 0-13, and for `quality` is 4-63. You can find the resolution corresponding to each size value in `camera_api.h`.

Here is an example of capturing an image using a serial command:

<img src="./images/Image_capture_by_serial.png">

---

### Part 2: Preparing Google Apps Script and ThingSpeak

**The source code for this part is available in the `Code/10_Images_Upload_GoogleDrive_ThingSpeak/` folder.**

#### Why Use Google Drive?

While ThingSpeak can accept images, this feature requires a paid license. The entry-level academic license costs over $300 per year and limits the maximum image size to 5MB.

In contrast, a free Google account includes 15 GB of Google Drive storage. This generous storage makes the one-time effort of setting up Google Drive integration a worthwhile alternative.

The following instructions assume you have a Google account.

#### Setting Up the Google Drive Uploader

We cannot upload a file directly from the ESP32-S3 to Google Drive. Instead, we need an intermediary web service that can receive the image data and use the Google Drive API to save it. **Google Apps Script** is the perfect tool for this job.

1.  Go to your Google Drive, click **New > More > Google Apps Script**, and open a new script project.
    <img src="./images/google_script_new.png">

2.  Give your project a descriptive name, such as "ESP32-S3 Image Uploader".

3.  Replace the placeholder `myFunction` code with the following script:

    ```javascript
    function doPost(e) {
      if (!e || !e.postData || !e.postData.contents) {
        // Return an error if no data is received
        return ContentService
          .createTextOutput(JSON.stringify({ status: "error", message: "No postData received" }))
          .setMimeType(ContentService.MimeType.JSON);
      }
    
      try {
        // Create unique names for the file and subfolder
        const name = Utilities.formatDate(new Date(), 'GMT+8', 'yyyyMMdd-HHmmss') + '.jpg';
        const subFolderName = Utilities.formatDate(new Date(), 'GMT+8', 'yyyyMMdd');
        const folderName = 'ESP32S3_CAM_IMG'; // Main folder
    
        // Decode the base64 image data
        const data = Utilities.base64Decode(e.postData.contents);
        const blob = Utilities.newBlob(data, 'image/jpeg', name);
    
        // Get or create the main folder
        let folder;
        const folders = DriveApp.getFoldersByName(folderName);
        folder = folders.hasNext() ? folders.next() : DriveApp.createFolder(folderName);
    
        // Get or create the daily subfolder
        let subFolder;
        const subFolders = folder.getFoldersByName(subFolderName);
        subFolder = subFolders.hasNext() ? subFolders.next() : folder.createFolder(subFolderName);
    
        // Create the file and set its sharing permissions
        const file = subFolder.createFile(blob);
        file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
        // Generate the public URL for the image
        const fileUrl = "https://drive.google.com/uc?export=view&id=" + file.getId();
        Logger.log(fileUrl);
    
        // Return a success status and the public URL
        return ContentService
          .createTextOutput(JSON.stringify({ status: "success", url: fileUrl }))
          .setMimeType(ContentService.MimeType.JSON);
      } catch (err) {
        // Log and return any errors
        Logger.log("Error during execution: " + err.toString());
        return ContentService
          .createTextOutput(JSON.stringify({ status: "error", message: err.toString() }))
          .setMimeType(ContentService.MimeType.JSON);
      }
    }
    ```

    Save the script by pressing `Ctrl+S`.

4.  Deploy the script as a web app. Click the **Deploy** button in the top-right corner and select **New deployment**. Click the gear icon next to "Select type" and choose **Web app**.

5.  In the configuration window:
    *   **Description**: "ESP32-S3 Camera Image Uploader"
    *   **Execute as**: "Me"
    *   **Who has access**: "Anyone" (This is critical for allowing the ESP32-S3 to call the script)

6.  Click **Deploy**.

7.  Google will prompt you to **Authorize access**. Grant the script the necessary permissions to access your Google Drive.

8.  After authorization, the deployment will provide a **Web app URL**. Copy this URL. It will look like `https://script.google.com/macros/s/<YOUR_DEPLOYMENT_ID>/exec`.

    <img src="./images/Google_web_app_url.jpg">

9.  Finally, create a folder in your Google Drive with the name you specified in the script (`ESP32S3_CAM_IMG`).

    <img src="./images/Google_web_app_folder.jpg">

#### Updating Your Arduino Code

The source code is in the `10_Images_Upload_GoogleDrive_ThingSpeak.ino` file. Paste the Web app URL you just copied into the `webAppUrl` constant:

```cpp
const String webAppUrl = "https://script.google.com/macros/s/<YOUR_DEPLOYMENT_ID>/exec";
```

The `uploadToGoogleDrive` function (located in `google_drive.cpp`) handles the HTTP POST request to this URL, sending the image data in the request body.

You can now test the program by uploading it to your ESP32-S3 and observing your Google Drive for new images.

[TODO: paste images here to demo]

#### Uploading the Image URL to ThingSpeak

Once an image is successfully uploaded to Google Drive, our Google Apps Script returns its public URL. The final step is to post this URL to a ThingSpeak channel.

The `uploadUrlToThingSpeak` function (in `thingspeak.cpp`) handles this by sending an HTTP GET request to the ThingSpeak API.

```cpp
// In 10_Images_Upload_GoogleDrive_ThingSpeak.ino
uploadUrlToThingSpeak(driveResponse, writeApiKey, thingSpeakFieldNumber);
```

-   `driveResponse`: A string containing the image URL returned by our Google Apps Script.
-   `writeApiKey`: Your ThingSpeak channel's Write API Key.
-   `thingSpeakFieldNumber`: The field number in your ThingSpeak channel where you want to store the URL (e.g., Field 2).

Now, when you trigger an image capture, the ESP32-S3 will manage the entire process, and you will see a new entry in your ThingSpeak channel containing a link to the captured image.

[TODO: Insert a screenshot of the ThingSpeak channel with an image link]

### Part 3: Integrating Image Upload into the Main Application

Once the manual trigger works reliably, the final step is to integrate this functionality into the main smart planter application (based on the code from `7_Run_WaterPump_with_Millis_ESP32`).

In the final version, the camera will automatically capture and upload an image whenever an abnormal condition is detected, such as when the soil moisture drops below a set threshold. This provides a valuable visual record corresponding to the sensor data.

This modular approach ensures that we can test each major component separately, leading to a smoother development experience and a more robust final project.

**Next:** Proceed to [Challenge 4: Using MQTT for Remote Control](4.4_Challenge4_Using_MQTT_for_RemoteControl.md).
